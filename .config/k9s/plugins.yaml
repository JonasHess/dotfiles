plugins:
  copy-yaml:
    shortCut: Ctrl-Y
    description: "copy yaml"
    scopes:
      - all
    command: zsh
    background: false
    args:
      - -c
      - |
        # Copy the YAML definition of a Kubernetes resource to clipboard
        set -euo pipefail
        
        echo "üìã Copying YAML for $RESOURCE_NAME/$NAME in namespace $NAMESPACE..."
        
        # Determine the clipboard command based on OS
        if command -v pbcopy &> /dev/null; then
          # macOS
          CLIPBOARD_CMD="pbcopy"
        elif command -v xclip &> /dev/null; then
          # Linux with xclip
          CLIPBOARD_CMD="xclip -selection clipboard"
        elif command -v xsel &> /dev/null; then
          # Linux with xsel
          CLIPBOARD_CMD="xsel --clipboard --input"
        elif command -v wl-copy &> /dev/null; then
          # Wayland
          CLIPBOARD_CMD="wl-copy"
        elif command -v clip.exe &> /dev/null; then
          # Windows
          CLIPBOARD_CMD="clip.exe"
        else
          echo "‚ùå No clipboard command found (pbcopy, xclip, xsel, wl-copy, or clip.exe)"
          echo "YAML will be displayed but not copied"
          CLIPBOARD_CMD="cat"
        fi
        
        # Ensure we use the exact resource type from K9s
        resource_spec="$RESOURCE_NAME"
        if [[ "$RESOURCE_NAME" != *"."* ]] && [[ -n "$RESOURCE_GROUP" ]]; then
          # If RESOURCE_NAME is just the plural name, use the full specification
          resource_spec="${RESOURCE_NAME}.${RESOURCE_GROUP}"
        fi
        
        # Get the resource YAML definition and copy to clipboard
        if ! kubectl get "$resource_spec" -n "$NAMESPACE" "$NAME" -o yaml --context "$CONTEXT" | tee >(eval "$CLIPBOARD_CMD"); then
          echo "‚ùå Failed to get resource YAML - check resource name and permissions"
          echo "Press enter to continue"
          read
          exit 1
        fi
        
        echo "‚úÖ YAML copied to clipboard successfully"
        echo "Press enter to continue"
        read
  exec-cluster:
    shortCut: Ctrl-X
    description: "connect to cluster"
    scopes:
      - kubernetesclusters
      - xkubernetesclusters
    command: zsh
    background: false
    args:
      - -c
      - |
        # Connect to a specific cluster and launch K9s with its configuration
        set -euo pipefail
        
        echo "üì° Connecting to cluster: $NAME..."
        if ! mscc k8s "$NAME"; then
          echo "‚ùå Failed to connect to cluster"
          echo "Press enter to continue"
          read
          exit 1
        fi
        
        echo "‚úÖ Connection successful, launching K9s"
        k9s --kubeconfig /tmp/kubeconfig
  
  test-cluster:
    shortCut: Ctrl-T
    description: "test cluster"
    scopes:
      - kubernetesclusters
      - xkubernetesclusters
    command: zsh
    background: false
    args:
      - -c
      - |
        # Run test operations on the selected cluster
        set -euo pipefail
        
        echo "üß™ Testing cluster: $NAME..."
        if ! mscc k8s "$NAME" -t; then
          echo "‚ùå Test failed"
        else
          echo "‚úÖ Test completed successfully"
        fi
        
        echo "Press enter to continue"
        read
  
  resource-trace:
    shortCut: Ctrl-B
    description: "beta trace"
    scopes:
      - all
    command: zsh
    background: false
    args:
      - -c
      - |
        # Trace dependencies for any Crossplane-managed resource
        set -euo pipefail
        
        echo "üîç Analyzing resource: $NAME in namespace: $NAMESPACE"
        echo "üîß Using resource type: $RESOURCE_NAME"
        echo "üîß Resource group: $RESOURCE_GROUP"
        
        # Use the exact resource specification from K9s
        # RESOURCE_NAME should be the full CRD name (e.g., xtenants.pgsql.ms.infinity.cgm.ag)
        # RESOURCE_GROUP should be the API group (e.g., pgsql.ms.infinity.cgm.ag)
        
        # Get the kind from the resource using the exact RESOURCE_NAME
        if ! kind=$(kubectl get "$RESOURCE_NAME" -n "$NAMESPACE" "$NAME" -o=jsonpath='{.kind}' --context "$CONTEXT" 2>/dev/null); then
          echo "‚ùå Failed to determine resource kind - is this a valid resource?"
          echo "Press enter to continue"
          read
          exit 1
        fi
        
        # Get the CRD to find the correct version
        crd_name="$RESOURCE_NAME"
        if [[ "$RESOURCE_NAME" != *"."* ]] && [[ -n "$RESOURCE_GROUP" ]]; then
          # If RESOURCE_NAME is just the plural name, construct the full CRD name
          crd_name="${RESOURCE_NAME}.${RESOURCE_GROUP}"
        fi
        
        echo "üîß Looking up CRD: $crd_name"
        
        # Get the storage version from the CRD
        if ! version=$(kubectl get crd "$crd_name" -o=jsonpath='{.spec.versions[?(@.storage==true)].name}' --context "$CONTEXT" 2>/dev/null); then
          echo "‚ùå Failed to get version from CRD $crd_name"
          # Fallback: try to get any version
          if ! version=$(kubectl get crd "$crd_name" -o=jsonpath='{.spec.versions[0].name}' --context "$CONTEXT" 2>/dev/null); then
            echo "‚ùå Failed to determine version for CRD $crd_name"
            echo "Press enter to continue"
            read
            exit 1
          fi
        fi
        
        # Extract group from CRD name (everything after the first dot)
        if [[ "$crd_name" == *"."* ]]; then
          group="${crd_name#*.}"
          crossplane_format="$kind.$version.$group"
        else
          # Core resource
          crossplane_format="$kind.$version"
        fi
        
        echo "üìä Resource: $crossplane_format - Running dependency trace"
        
        # Run crossplane trace with proper format
        if ! watch crossplane beta trace "$crossplane_format/$NAME" -n "$NAMESPACE"; then
          echo "‚ùå Trace failed - is this a Crossplane-managed resource?"
        else
          echo "‚úÖ Trace completed"
        fi
        
        echo "Press enter to continue"
        read

  watch-events:
    shortCut: Shift-E
    description: "watch events"
    scopes:
      - all
    command: zsh
    background: false
    args:
      - -c
      - |
        # Stream Kubernetes events for the selected resource
        set -euo pipefail
        
        echo "üëÅÔ∏è Watching events for $RESOURCE_NAME/$NAME in namespace $NAMESPACE"
        echo "‚å®Ô∏è Press Ctrl+C to exit"
        
        # Use kubectl events command with proper error handling
        if ! kubectl events --context "$CONTEXT" --namespace "$NAMESPACE" \
           --for "$RESOURCE_NAME.$RESOURCE_GROUP/$NAME" --watch; then
          echo "‚ùå Failed to watch events - check resource name and permissions"
          echo "Press enter to continue"
          read
          exit 1
        fi

  argocd-sync:
    shortCut: Shift-A
    description: "sync ArgoCD Application"
    scopes:
      - application
    command: zsh
    background: true
    confirm: true
    args:
      - -c
      - |
        # Synchronize an ArgoCD application
        set -euo pipefail
        
        echo "üîÑ Starting sync for ArgoCD application: $NAME in namespace: $NAMESPACE"
        
        if ! argocd app sync "$NAME" --app-namespace "$NAMESPACE"; then
          # We don't show this error since the command runs in background
          # but we'll log it to the background process
          echo "‚ùå Sync failed for application: $NAME" >&2
          exit 1
        fi

  pg-status:
    shortCut: i
    description: "cnpg status"
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Display database cluster status
        set -euo pipefail
        echo "üìä Retrieving status for $NAME in namespace $NAMESPACE"
        kubectl cnpg status "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  pg-status-verbose:
    shortCut: Shift-S
    description: "cnpg status -v"
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Display detailed database cluster status
        set -euo pipefail
        echo "üîç Retrieving detailed status for $NAME in namespace $NAMESPACE"
        kubectl cnpg status "$NAME" -n "$NAMESPACE" --context "$CONTEXT" --verbose |& less -R

  pg-logs:
    shortCut: l
    description: "cnpg logs (pretty)"
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Stream pretty printed logs from the database cluster
        set -euo pipefail
        echo "üìä Streaming pretty printed logs for $NAME in namespace $NAMESPACE"
        kubectl cnpg logs cluster "$NAME" -f -n "$NAMESPACE" --context "$CONTEXT" | kubectl cnpg logs pretty

  pg-logs-raw:
    shortCut: Shift-L
    description: "cnpg logs (raw)"
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Stream raw logs from the database cluster
        set -euo pipefail
        echo "üìú Streaming raw logs for $NAME in namespace $NAMESPACE"
        kubectl cnpg logs cluster "$NAME" -f -n "$NAMESPACE" --context "$CONTEXT"

  pg-shell:
    shortCut: p
    description: "cnpg psql"
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Open an interactive PSQL shell to the database
        set -euo pipefail
        echo "üêò Opening PostgreSQL shell for $NAME in namespace $NAMESPACE"
        kubectl cnpg psql "$NAME" -n "$NAMESPACE" --context "$CONTEXT"

  # --- Database Maintenance Operations ---

  pg-backup:
    shortCut: b
    description: "cnpg backup"
    scopes:
      - cluster
    command: zsh
    confirm: true
    background: false
    args:
      - -c
      - |
        # Create a backup of the database cluster
        set -euo pipefail
        echo "üíæ Creating backup for $NAME in namespace $NAMESPACE"
        kubectl cnpg backup "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  pg-reload:
    shortCut: r
    description: "cnpg reload"
    confirm: true
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Reload database configuration without restart
        set -euo pipefail
        echo "üîÑ Reloading configuration for $NAME in namespace $NAMESPACE"
        kubectl cnpg reload "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  pg-restart:
    shortCut: Shift-R
    description: "cnpg restart"
    confirm: true
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Restart the database cluster
        set -euo pipefail
        echo "üîÑ Restarting cluster $NAME in namespace $NAMESPACE"
        kubectl cnpg restart "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  # --- Hibernation Controls ---

  pg-hibernate-status:
    shortCut: h
    description: "cnpg hibernate status"
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Check hibernate status of database cluster
        set -euo pipefail
        echo "üí§ Checking hibernation status for $NAME in namespace $NAMESPACE"
        kubectl cnpg hibernate status "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  pg-hibernate:
    shortCut: Shift-H
    description: "cnpg hibernate on"
    confirm: true
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Put database cluster into hibernation
        set -euo pipefail
        echo "üí§ Hibernating cluster $NAME in namespace $NAMESPACE"
        kubectl cnpg hibernate on "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  pg-hibernate-off:
    shortCut: Shift-W
    description: "cnpg hibernate off"
    confirm: true
    scopes:
      - namespace
    command: zsh
    background: false
    args:
      - -c
      - |
        # Wake up a hibernated database cluster
        set -euo pipefail
        echo "‚è∞ Waking up hibernated clusters in namespace $NAME"
        kubectl cnpg hibernate off "$NAME" -n "$NAME" --context "$CONTEXT" |& less -R

  download-kubeconfig:
    shortCut: Ctrl-J
    description: "download kubeConfig"
    scopes:
      - xkubernetesclusters
    command: zsh
    background: false
    args:
      - -c
      - |
        # Download kubeConfig for xkubernetesclusters resource
        set -euo pipefail
        
        echo "üì• Downloading kubeConfig for: $NAME"
        
        # Ensure the directory exists
        mkdir -p ~/.kube/config.d/
        
        # Set the path using just the resource name
        CONFIG_PATH=~/.kube/config.d/${NAME}
        
        echo "üìÅ Saving to: $CONFIG_PATH"
        
        # Extract the kubeConfig, decode it, and save it directly to the final path
        if ! kubectl get xkubernetesclusters.k8s.ms.infinity.cgm.ag "$NAME" -o jsonpath='{.status.kubeConfig}' | base64 -d > "$CONFIG_PATH"; then
          echo "‚ùå Failed to download kubeConfig"
          echo "Press enter to continue"
          read
          exit 1
        fi
        
        # Set appropriate permissions
        chmod 600 "$CONFIG_PATH"
        
        echo "‚úÖ KubeConfig downloaded successfully to: $CONFIG_PATH"
        echo "Press enter to continue"
        read